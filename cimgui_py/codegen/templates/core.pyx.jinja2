# cython: language_level=3
# cython: embedsignature=True
"""core.pyx - Auto-generated ImGui bindings (纯 C API)

DO NOT EDIT - regenerate with: python codegen/compiler.py

架构说明：
- 直接调用 cimgui 的纯 C 函数
- 不涉及 C++ 类型或转换
- ImVec2/ImVec4 等是 cimgui 定义的纯 C 结构体
"""

from libc.stdlib cimport malloc, free
from libc.string cimport memcpy, strlen
from cython.view cimport array as cvarray
from cimgui_py cimport cimgui

# ==============================================================================
# Helpers
# ==============================================================================

cdef inline bytes _to_bytes(s):
    """str -> bytes"""
    if isinstance(s, bytes):
        return s
    if s is None:
        return b''
    return s.encode('utf-8')


cdef inline void* _get_ptr(obj):
    """Extract pointer from wrapper object or raw int.

    Supports:
    - Wrapper objects with _pointer property (Context, Font, etc.)
    - Raw int/size_t pointer values (for backward compatibility)
    """
    if hasattr(obj, '_pointer'):
        return <void*><size_t>obj._pointer
    return <void*><size_t>obj


# ==============================================================================
# Callback System - Python callable <-> C callback bridge
# ==============================================================================

# Global callback storage (prevents GC of Python callables)
cdef dict _input_text_callbacks = {}
cdef dict _size_callbacks = {}
cdef int _callback_id_counter = 0


cdef int _input_text_callback_wrapper(cimgui.ImGuiInputTextCallbackData* data) noexcept with gil:
    """C callback wrapper for InputTextCallback -> Python callable.

    The callback ID is stored in UserData field.
    """
    cdef size_t callback_id = <size_t>data.UserData
    if callback_id in _input_text_callbacks:
        py_callback = _input_text_callbacks[callback_id]
        # Create wrapper for callback data
        wrapper = InputTextCallbackData._wrap(<size_t>data)
        try:
            result = py_callback(wrapper)
            return result if result is not None else 0
        except Exception as e:
            import sys
            print(f"Error in input_text callback: {e}", file=sys.stderr)
            return 0
    return 0


cdef void _size_callback_wrapper(cimgui.ImGuiSizeCallbackData* data) noexcept with gil:
    """C callback wrapper for SizeCallback -> Python callable.

    The callback ID is stored in UserData field.
    """
    cdef size_t callback_id = <size_t>data.UserData
    if callback_id in _size_callbacks:
        py_callback = _size_callbacks[callback_id]
        # Create wrapper for callback data
        wrapper = SizeCallbackData._wrap(<size_t>data)
        try:
            py_callback(wrapper)
        except Exception as e:
            import sys
            print(f"Error in size callback: {e}", file=sys.stderr)


cdef size_t _register_input_text_callback(object callback):
    """Register a Python callback and return its ID."""
    global _callback_id_counter
    _callback_id_counter += 1
    _input_text_callbacks[_callback_id_counter] = callback
    return _callback_id_counter


cdef size_t _register_size_callback(object callback):
    """Register a Python callback and return its ID."""
    global _callback_id_counter
    _callback_id_counter += 1
    _size_callbacks[_callback_id_counter] = callback
    return _callback_id_counter


cdef void _unregister_input_text_callback(size_t callback_id):
    """Unregister a callback after use."""
    _input_text_callbacks.pop(callback_id, None)


cdef void _unregister_size_callback(size_t callback_id):
    """Unregister a callback after use."""
    _size_callbacks.pop(callback_id, None)


# ==============================================================================
# Array wrapper classes for struct fields
# ==============================================================================

cdef class _MouseDownArray:
    """Helper for MouseDown[5] array access"""
    cdef void* _ptr

    def __cinit__(self):
        self._ptr = NULL

    @staticmethod
    cdef _MouseDownArray create(void* ptr):
        cdef _MouseDownArray obj = _MouseDownArray.__new__(_MouseDownArray)
        obj._ptr = ptr
        return obj

    def __len__(self):
        return 5

    def __getitem__(self, int idx):
        if idx < 0 or idx >= 5:
            raise IndexError(f"Index {idx} out of range [0, 5)")
        return (<cimgui.ImGuiIO*>self._ptr).MouseDown[idx]

    def __setitem__(self, int idx, bint value):
        if idx < 0 or idx >= 5:
            raise IndexError(f"Index {idx} out of range [0, 5)")
        (<cimgui.ImGuiIO*>self._ptr).MouseDown[idx] = value


# ==============================================================================
# Value-Type Struct Conversion Functions (自动生成)
# ==============================================================================
{% for struct in structs.values() if struct.is_value_type and struct.has_simple_fields %}
{% set conv_name = (struct.name | strip_im_prefix) | snake_case %}

cdef inline cimgui.{{ struct.name }} _{{ conv_name }}(val):
    """tuple/list -> {{ struct.name }}"""
    cdef cimgui.{{ struct.name }} v
    if val is None:
{% for field in struct.simple_fields %}
{% if field.cython_type.endswith('*') %}
        v.{{ field.name }} = NULL
{% elif field.cython_type.startswith('Im') %}
        v.{{ field.name }} = _{{ (field.cython_type | strip_im_prefix) | snake_case }}(None)
{% else %}
        v.{{ field.name }} = 0
{% endif %}
{% endfor %}
    else:
{% for field in struct.simple_fields %}
{% if field.cython_type == 'float' %}
        v.{{ field.name }} = <float>val[{{ loop.index0 }}]
{% elif field.cython_type in ('int', 'bint') %}
        v.{{ field.name }} = <int>val[{{ loop.index0 }}]
{% elif field.cython_type == 'void*' %}
        v.{{ field.name }} = <void*><size_t>val[{{ loop.index0 }}]
{% elif field.cython_type.endswith('*') %}
        v.{{ field.name }} = <cimgui.{{ field.cython_type[:-1] }}*><size_t>val[{{ loop.index0 }}]
{% elif field.cython_type.startswith('Im') %}
        v.{{ field.name }} = _{{ (field.cython_type | strip_im_prefix) | snake_case }}(val[{{ loop.index0 }}])
{% else %}
        v.{{ field.name }} = val[{{ loop.index0 }}]
{% endif %}
{% endfor %}
    return v


cdef inline tuple _{{ conv_name }}_to_tuple(cimgui.{{ struct.name }} v):
    """{{ struct.name }} -> tuple"""
    return ({% for field in struct.simple_fields %}{% if field.cython_type.endswith('*') %}<size_t>v.{{ field.name }}{% else %}v.{{ field.name }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %})

{% endfor %}

{# ============================================================================
   Macro: convert argument for C call
   自动匹配值类型结构体的转换函数
   ============================================================================ #}
{% macro convert_arg(arg) -%}
{% if arg.conversion == 'to_bytes' -%}
_to_bytes({{ arg.name }})
{%- elif arg.conversion == 'ptr' -%}
{# For ptr conversion: void* and const T* can use simple cast #}
{# If arg.wrapper is set, extract ._pointer from wrapper object #}
{% if arg.wrapper -%}
{# Wrapper type: extract ._pointer, support both wrapper and raw int #}
{% if arg.default is not none -%}
(_get_ptr({{ arg.name }}) if {{ arg.name }} is not None else NULL)
{%- else -%}
_get_ptr({{ arg.name }})
{%- endif %}
{%- elif arg.default is not none -%}
{# Optional pointer: need NULL check #}
{% if arg.cython_type == 'void*' or arg.cython_type == 'const void*' -%}
(<void*><size_t>{{ arg.name }} if {{ arg.name }} is not None else NULL)
{%- elif arg.cython_type.startswith('const ') -%}
(<{{ arg.cython_type[6:] }}><size_t>{{ arg.name }} if {{ arg.name }} is not None else NULL)
{%- else -%}
(<cimgui.{{ arg.cython_type }}><size_t>{{ arg.name }} if {{ arg.name }} is not None else NULL)
{%- endif %}
{%- else -%}
{# Required pointer: simple cast #}
{% if arg.cython_type == 'void*' or arg.cython_type == 'const void*' -%}
<void*><size_t>{{ arg.name }}
{%- elif arg.cython_type.startswith('const ') -%}
<{{ arg.cython_type[6:] }}><size_t>{{ arg.name }}
{%- else -%}
<cimgui.{{ arg.cython_type }}><size_t>{{ arg.name }}
{%- endif %}
{%- endif %}
{%- elif arg.conversion and arg.conversion.startswith('float_array') -%}
_arr_{{ arg.name }}
{%- elif arg.conversion and arg.conversion.startswith('int_array') -%}
_arr_{{ arg.name }}
{%- elif arg.conversion and arg.conversion.endswith('_ptr') -%}
{# Native pointer types: pass address of temp variable or NULL for optional #}
{% if arg.default is not none -%}
(&_tmp_{{ arg.name }} if {{ arg.name }} is not None else NULL)
{%- else -%}
&_tmp_{{ arg.name }}
{%- endif %}
{%- elif arg.conversion -%}
{# Value-type struct conversion: call _<conv_name>(arg) #}
_{{ arg.conversion }}({{ arg.name }})
{%- else -%}
{{ arg.name }}
{%- endif %}
{%- endmacro %}

{# ============================================================================
   Macro: check if function has pointer arguments (output params)
   ============================================================================ #}
{% macro has_ptr_args(func) -%}
{% for arg in func.args %}{% if arg.conversion and arg.conversion.endswith('_ptr') %}1{% endif %}{% endfor %}
{%- endmacro %}

{# ============================================================================
   Macro: check if function has array arguments
   ============================================================================ #}
{% macro has_array_args(func) -%}
{% for arg in func.args %}{% if arg.conversion and ('_array_' in arg.conversion) %}1{% endif %}{% endfor %}
{%- endmacro %}

# ==============================================================================
# Wrapper Classes (自动生成)
# ==============================================================================
# Wrapper types registry for wrapping C pointers
WRAPPER_TYPES = {}

{% for stname, wrapper_info in type_map.WRAPPER_TYPES.items() %}
{% set wrapper_name = wrapper_info[0] %}
{% set method_list = methods.get(stname, []) %}

cdef class {{ wrapper_name }}:
    """Wrapper for {{ stname }}* pointer.

    Provides type-safe access to {{ stname }} methods.
    Do not construct directly - use factory functions like get_window_draw_list().
    """
    cdef void* _ptr

    def __cinit__(self):
        self._ptr = NULL

    @staticmethod
    def _wrap(ptr: int) -> "{{ wrapper_name }}":
        """Internal: wrap a C pointer (as int)"""
        cdef {{ wrapper_name }} obj = {{ wrapper_name }}.__new__({{ wrapper_name }})
        obj._ptr = <void*><size_t>ptr
        return obj

    @property
    def _pointer(self) -> int:
        """Get the raw pointer value (for advanced use)."""
        return <size_t>self._ptr

    def __repr__(self):
        return f"<{{ wrapper_name }} ptr=0x{<size_t>self._ptr:x}>"

    def __bool__(self):
        """Check if pointer is valid (non-NULL)."""
        return self._ptr != NULL

{# ------ Struct Field Properties ------ #}
{% set struct_info = structs.get(stname) %}
{% set full_struct_names = type_map.get_full_struct_defs() %}
{% if struct_info and stname in full_struct_names %}
{# === Non-array fields === #}
{% for fld in struct_info.fields %}
{% if not fld.skip and fld.size is none and fld.cython_type != '__UNKNOWN__' %}
{% set prop_name = fld.name | strip_array_suffix | to_snake_case %}
{% set c_field_name = fld.name | strip_array_suffix %}
{% if fld.conversion == 'vec2' or fld.c_type == 'ImVec2' %}
    @property
    def {{ prop_name }}(self) -> tuple:
        """{{ fld.c_type }} {{ fld.name }}"""
        cdef cimgui.ImVec2 v = (<cimgui.{{ stname }}*>self._ptr).{{ c_field_name }}
        return (v.x, v.y)

    @{{ prop_name }}.setter
    def {{ prop_name }}(self, value: tuple):
        (<cimgui.{{ stname }}*>self._ptr).{{ c_field_name }}.x = value[0]
        (<cimgui.{{ stname }}*>self._ptr).{{ c_field_name }}.y = value[1]

{% elif fld.conversion == 'vec4' or fld.c_type == 'ImVec4' %}
    @property
    def {{ prop_name }}(self) -> tuple:
        """{{ fld.c_type }} {{ fld.name }}"""
        cdef cimgui.ImVec4 v = (<cimgui.{{ stname }}*>self._ptr).{{ c_field_name }}
        return (v.x, v.y, v.z, v.w)

    @{{ prop_name }}.setter
    def {{ prop_name }}(self, value: tuple):
        (<cimgui.{{ stname }}*>self._ptr).{{ c_field_name }}.x = value[0]
        (<cimgui.{{ stname }}*>self._ptr).{{ c_field_name }}.y = value[1]
        (<cimgui.{{ stname }}*>self._ptr).{{ c_field_name }}.z = value[2]
        (<cimgui.{{ stname }}*>self._ptr).{{ c_field_name }}.w = value[3]

{% elif fld.cython_type == 'bint' %}
    @property
    def {{ prop_name }}(self) -> bool:
        """{{ fld.c_type }} {{ fld.name }}"""
        return (<cimgui.{{ stname }}*>self._ptr).{{ c_field_name }}

    @{{ prop_name }}.setter
    def {{ prop_name }}(self, value: bool):
        (<cimgui.{{ stname }}*>self._ptr).{{ c_field_name }} = value

{% elif fld.cython_type in ['float', 'double', 'int', 'unsigned int', 'short', 'unsigned short'] %}
    @property
    def {{ prop_name }}(self) -> {{ fld.python_type }}:
        """{{ fld.c_type }} {{ fld.name }}"""
        return (<cimgui.{{ stname }}*>self._ptr).{{ c_field_name }}

    @{{ prop_name }}.setter
    def {{ prop_name }}(self, value: {{ fld.python_type }}):
        (<cimgui.{{ stname }}*>self._ptr).{{ c_field_name }} = value

{% elif fld.cython_type == 'const char*' %}
    @property
    def {{ prop_name }}(self) -> str | None:
        """{{ fld.c_type }} {{ fld.name }}"""
        cdef const char* s = (<cimgui.{{ stname }}*>self._ptr).{{ c_field_name }}
        if s == NULL:
            return None
        return s.decode('utf-8')

{% elif fld.cython_type.endswith('*') and fld.wrapper %}
{# Pointer to wrapper type: return wrapper object #}
    @property
    def {{ prop_name }}(self) -> {{ fld.wrapper }}:
        """{{ fld.c_type }} {{ fld.name }}"""
        cdef void* ptr = <void*>(<cimgui.{{ stname }}*>self._ptr).{{ c_field_name }}
        if ptr == NULL:
            return None
        return {{ fld.wrapper }}._wrap(<size_t>ptr)

{% elif fld.cython_type.endswith('*') %}
{# Other pointer types: return raw int #}
    @property
    def {{ prop_name }}(self) -> int:
        """{{ fld.c_type }} {{ fld.name }} (raw pointer)"""
        return <size_t>(<cimgui.{{ stname }}*>self._ptr).{{ c_field_name }}

{% endif %}
{% endif %}
{% endfor %}
{# === Array fields (with memoryview/wrapper access) === #}
{% for fld in struct_info.fields %}
{% if not fld.skip and fld.size is not none and fld.cython_type != '__UNKNOWN__' %}
{% set prop_name = fld.name | strip_array_suffix | to_snake_case %}
{% set c_field_name = fld.name | strip_array_suffix %}
{% if fld.cython_type == 'bint' %}
{# Bool arrays: use wrapper class since memoryview doesn't support C++ bool well #}
{% if c_field_name == 'MouseDown' %}
    @property
    def {{ prop_name }}(self):
        """{{ fld.c_type }} {{ fld.name }} - indexed array access

        Usage: io.{{ prop_name }}[0], io.{{ prop_name }}[1] = True, ...
        """
        return _MouseDownArray.create(self._ptr)

{% else %}
{# Other bool arrays: use indexed accessor methods #}
    def get_{{ prop_name }}(self, int idx) -> bool:
        """{{ fld.c_type }} {{ fld.name }} - indexed array access"""
        if idx < 0 or idx >= {{ fld.size }}:
            raise IndexError(f"{{ prop_name }} index {idx} out of range [0, {{ fld.size }})")
        return (<cimgui.{{ stname }}*>self._ptr).{{ c_field_name }}[idx]

    def set_{{ prop_name }}(self, int idx, bint value):
        if idx < 0 or idx >= {{ fld.size }}:
            raise IndexError(f"{{ prop_name }} index {idx} out of range [0, {{ fld.size }})")
        (<cimgui.{{ stname }}*>self._ptr).{{ c_field_name }}[idx] = value

{% endif %}
{% elif fld.cython_type == 'float' %}
    @property
    def {{ prop_name }}(self):
        """{{ fld.c_type }} {{ fld.name }} - memoryview array access

        Usage: style.{{ prop_name }}[0], style.{{ prop_name }}[1] = 1.0, ...
        """
        cdef cvarray arr = cvarray(
            shape=({{ fld.size }},),
            itemsize=sizeof(float),
            format='f',
            allocate_buffer=False
        )
        arr.data = <char*>(<cimgui.{{ stname }}*>self._ptr).{{ c_field_name }}
        return arr

{% elif fld.cython_type == 'double' %}
    @property
    def {{ prop_name }}(self):
        """{{ fld.c_type }} {{ fld.name }} - memoryview array access"""
        cdef cvarray arr = cvarray(
            shape=({{ fld.size }},),
            itemsize=sizeof(double),
            format='d',
            allocate_buffer=False
        )
        arr.data = <char*>(<cimgui.{{ stname }}*>self._ptr).{{ c_field_name }}
        return arr

{% elif fld.cython_type == 'int' %}
    @property
    def {{ prop_name }}(self):
        """{{ fld.c_type }} {{ fld.name }} - memoryview array access"""
        cdef cvarray arr = cvarray(
            shape=({{ fld.size }},),
            itemsize=sizeof(int),
            format='i',
            allocate_buffer=False
        )
        arr.data = <char*>(<cimgui.{{ stname }}*>self._ptr).{{ c_field_name }}
        return arr

{% elif fld.cython_type == 'unsigned int' %}
    @property
    def {{ prop_name }}(self):
        """{{ fld.c_type }} {{ fld.name }} - memoryview array access"""
        cdef cvarray arr = cvarray(
            shape=({{ fld.size }},),
            itemsize=sizeof(unsigned int),
            format='I',
            allocate_buffer=False
        )
        arr.data = <char*>(<cimgui.{{ stname }}*>self._ptr).{{ c_field_name }}
        return arr

{% elif fld.conversion == 'vec2' or fld.c_type == 'ImVec2' %}
{# ImVec2 arrays need special handling - use helper methods #}
    def get_{{ prop_name }}(self, idx: int) -> tuple:
        """{{ fld.c_type }} {{ fld.name }} - indexed array access"""
        if idx < 0 or idx >= {{ fld.size }}:
            raise IndexError(f"{{ prop_name }} index {idx} out of range [0, {{ fld.size }})")
        cdef cimgui.ImVec2 v = (<cimgui.{{ stname }}*>self._ptr).{{ c_field_name }}[idx]
        return (v.x, v.y)

    def set_{{ prop_name }}(self, idx: int, value: tuple):
        if idx < 0 or idx >= {{ fld.size }}:
            raise IndexError(f"{{ prop_name }} index {idx} out of range [0, {{ fld.size }})")
        (<cimgui.{{ stname }}*>self._ptr).{{ c_field_name }}[idx].x = value[0]
        (<cimgui.{{ stname }}*>self._ptr).{{ c_field_name }}[idx].y = value[1]

{% endif %}
{% endif %}
{% endfor %}
{% endif %}

{% for func in method_list %}
{% set override = overrides.get('methods', {}).get(func.ov_cimguiname, {}) %}
{% if not override.get('skip') %}
{% set ptr_args = [] %}
{% set array_args = [] %}
{% for arg in func.args %}
{% if arg.conversion and arg.conversion.endswith('_ptr') %}{% set _ = ptr_args.append(arg) %}{% endif %}
{% if arg.conversion and '_array_' in arg.conversion %}{% set _ = array_args.append(arg) %}{% endif %}
{% endfor %}
{% if override.get('signature') %}
    def {{ func.python_name }}{{ override.signature }}:
        """{{ func.cimgui_name }}"""
        {{ override.body | indent(8) }}
{% elif ptr_args %}
{# Check if any ptr_arg is optional #}
{% set has_optional_ptr = namespace(value=false) %}
{% for ptr_arg in ptr_args %}{% if ptr_arg.default is not none %}{% set has_optional_ptr.value = true %}{% endif %}{% endfor %}

    def {{ func.python_name }}(self{% for arg in func.args %}, {{ arg.name }}{% if arg.default is not none %} = {{ arg.default }}{% endif %}{% endfor %}):
        """{{ func.cimgui_name }} - method with output parameters"""
{% for ptr_arg in ptr_args %}
{% set ctype = {'bool_ptr': 'bint', 'int_ptr': 'int', 'uint_ptr': 'int', 'float_ptr': 'float', 'double_ptr': 'double'}[ptr_arg.conversion] %}
{% if ptr_arg.default is not none %}
        cdef {{ ctype }} _tmp_{{ ptr_arg.name }} = {{ ptr_arg.name }} if {{ ptr_arg.name }} is not None else 0
{% else %}
        cdef {{ ctype }} _tmp_{{ ptr_arg.name }} = {{ ptr_arg.name }}
{% endif %}
{% endfor %}
{% if func.ret_python == 'None' %}
        cimgui.{{ func.ov_cimguiname }}(<cimgui.{{ stname }}*>self._ptr{% for arg in func.args %}, {{ convert_arg(arg) }}{% endfor %})
{% if has_optional_ptr.value %}
        return ({% for ptr_arg in ptr_args %}{% if ptr_arg.default is not none %}({% endif %}{% if ptr_arg.conversion == 'bool_ptr' %}bool(_tmp_{{ ptr_arg.name }}){% else %}_tmp_{{ ptr_arg.name }}{% endif %}{% if ptr_arg.default is not none %} if {{ ptr_arg.name }} is not None else None){% endif %}{% if not loop.last %}, {% endif %}{% endfor %})
{% else %}
        return ({% for ptr_arg in ptr_args %}{% if ptr_arg.conversion == 'bool_ptr' %}bool(_tmp_{{ ptr_arg.name }}){% else %}_tmp_{{ ptr_arg.name }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %})
{% endif %}
{% else %}
        cdef {{ func.ret_cython }} _result = cimgui.{{ func.ov_cimguiname }}(<cimgui.{{ stname }}*>self._ptr{% for arg in func.args %}, {{ convert_arg(arg) }}{% endfor %})
{% if has_optional_ptr.value %}
        return (_result, {% for ptr_arg in ptr_args %}{% if ptr_arg.default is not none %}({% endif %}{% if ptr_arg.conversion == 'bool_ptr' %}bool(_tmp_{{ ptr_arg.name }}){% else %}_tmp_{{ ptr_arg.name }}{% endif %}{% if ptr_arg.default is not none %} if {{ ptr_arg.name }} is not None else None){% endif %}{% if not loop.last %}, {% endif %}{% endfor %})
{% else %}
        return (_result, {% for ptr_arg in ptr_args %}{% if ptr_arg.conversion == 'bool_ptr' %}bool(_tmp_{{ ptr_arg.name }}){% else %}_tmp_{{ ptr_arg.name }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %})
{% endif %}
{% endif %}
{% else %}
    def {{ func.python_name }}(self{% for arg in func.args %}, {{ arg.name }}{% if arg.default is not none %} = {{ arg.default }}{% endif %}{% endfor %}):
        """{{ func.cimgui_name }}"""
{% if func.ret_python == 'None' %}
        cimgui.{{ func.ov_cimguiname }}(<cimgui.{{ stname }}*>self._ptr{% for arg in func.args %}, {{ convert_arg(arg) }}{% endfor %})
{% elif func.ret_conversion == 'vec2_to_tuple' %}
        cdef cimgui.ImVec2 result = cimgui.{{ func.ov_cimguiname }}(<cimgui.{{ stname }}*>self._ptr{% for arg in func.args %}, {{ convert_arg(arg) }}{% endfor %})
        return _vec2_to_tuple(result)
{% elif func.ret_conversion == 'vec4_to_tuple' %}
        cdef cimgui.ImVec4 result = cimgui.{{ func.ov_cimguiname }}(<cimgui.{{ stname }}*>self._ptr{% for arg in func.args %}, {{ convert_arg(arg) }}{% endfor %})
        return _vec4_to_tuple(result)
{% elif func.ret_conversion == 'char_ptr_to_str' %}
        cdef const char* _cstr = cimgui.{{ func.ov_cimguiname }}(<cimgui.{{ stname }}*>self._ptr{% for arg in func.args %}, {{ convert_arg(arg) }}{% endfor %})
        return _cstr.decode('utf-8') if _cstr != NULL else ''
{% elif func.ret_wrapper %}
        cdef void* _wptr = cimgui.{{ func.ov_cimguiname }}(<cimgui.{{ stname }}*>self._ptr{% for arg in func.args %}, {{ convert_arg(arg) }}{% endfor %})
        return {{ func.ret_wrapper }}._wrap(<size_t>_wptr) if _wptr != NULL else None
{% elif func.ret_cython.endswith('*') %}
        return <size_t>cimgui.{{ func.ov_cimguiname }}(<cimgui.{{ stname }}*>self._ptr{% for arg in func.args %}, {{ convert_arg(arg) }}{% endfor %})
{% else %}
        return cimgui.{{ func.ov_cimguiname }}(<cimgui.{{ stname }}*>self._ptr{% for arg in func.args %}, {{ convert_arg(arg) }}{% endfor %})
{% endif %}
{% endif %}

{% endif %}
{% endfor %}

# Register wrapper type for dynamic lookup
WRAPPER_TYPES['{{ stname }}'] = {{ wrapper_name }}

{% endfor %}

# ==============================================================================
# Core Functions (需要特殊处理)
# ==============================================================================

def destroy_context(ctx = None):
    """Destroy ImGui context. ctx=None to destroy current context."""
    cdef cimgui.ImGuiContext* ptr = NULL
    if ctx is not None:
        # Support both Context wrapper and raw int pointer
        if hasattr(ctx, '_pointer'):
            ptr = <cimgui.ImGuiContext*><size_t>ctx._pointer
        else:
            ptr = <cimgui.ImGuiContext*><size_t>ctx
    cimgui.igDestroyContext(ptr)


def begin(name: str, closable = None, flags: int = 0):
    """Begin a window.

    Args:
        name: Window title
        closable: If None, window has no close button. If True/False, initial open state.

    Returns:
        If closable is None: bool (visible)
        If closable is not None: (visible, open) tuple
    """
    cdef bytes name_bytes = _to_bytes(name)
    cdef bint result
    cdef bint p_open = True

    if closable is None:
        result = cimgui.igBegin(name_bytes, NULL, flags)
        return result
    else:
        p_open = closable
        result = cimgui.igBegin(name_bytes, &p_open, flags)
        return (result, bool(p_open))


def end():
    """End current window."""
    cimgui.igEnd()


def text(txt: str):
    """Display text (uses TextUnformatted internally)."""
    cdef bytes txt_bytes = _to_bytes(txt)
    cimgui.igTextUnformatted(txt_bytes, NULL)


def text_colored(color, txt: str):
    """Display colored text."""
    cdef bytes txt_bytes = _to_bytes(txt)
    cimgui.igTextColored(_vec4(color), txt_bytes)


def checkbox(label: str, state: bool):
    """Checkbox widget. Returns (clicked, new_state)."""
    cdef bytes label_bytes = _to_bytes(label)
    cdef bint c_state = state
    cdef bint clicked = cimgui.igCheckbox(label_bytes, &c_state)
    return (clicked, bool(c_state))


def slider_float(label: str, value: float, v_min: float, v_max: float, format: str = "%.3f", flags: int = 0):
    """Float slider. Returns (changed, new_value)."""
    cdef bytes label_bytes = _to_bytes(label)
    cdef bytes format_bytes = _to_bytes(format)
    cdef float c_value = value
    cdef bint changed = cimgui.igSliderFloat(label_bytes, &c_value, v_min, v_max, format_bytes, flags)
    return (changed, c_value)


def slider_int(label: str, value: int, v_min: int, v_max: int, format: str = "%d", flags: int = 0):
    """Int slider. Returns (changed, new_value)."""
    cdef bytes label_bytes = _to_bytes(label)
    cdef bytes format_bytes = _to_bytes(format)
    cdef int c_value = value
    cdef bint changed = cimgui.igSliderInt(label_bytes, &c_value, v_min, v_max, format_bytes, flags)
    return (changed, c_value)


def input_text(label: str, value: str, buffer_size: int = 256, flags: int = 0, callback = None):
    """Text input widget with optional callback.

    Args:
        label: Widget label (##id for hidden label)
        value: Current text value
        buffer_size: Maximum buffer size
        flags: InputTextFlags
        callback: Optional callback function(data: InputTextCallbackData) -> int
                  Called for filtering, history, completion, etc.
                  The callback receives an InputTextCallbackData wrapper with:
                  - event_flag: Which event triggered the callback
                  - event_char: Character for CharFilter events (writable)
                  - event_key: Key for special key events
                  - buf: Current buffer content
                  - cursor_pos: Cursor position (writable)
                  - selection_start/end: Selection range (writable)

    Returns:
        (changed: bool, new_value: str) tuple
    """
    cdef bytes label_bytes = _to_bytes(label)
    cdef bytes value_bytes = _to_bytes(value)
    cdef char* buf = <char*>malloc(buffer_size)
    cdef size_t copy_len
    cdef size_t callback_id = 0
    cdef cimgui.ImGuiInputTextCallback c_callback = NULL
    cdef void* user_data = NULL

    if buf == NULL:
        raise MemoryError()

    # Setup callback if provided
    if callback is not None:
        callback_id = _register_input_text_callback(callback)
        c_callback = _input_text_callback_wrapper
        user_data = <void*>callback_id

    try:
        copy_len = min(len(value_bytes), buffer_size - 1)
        memcpy(buf, <char*>value_bytes, copy_len)
        buf[copy_len] = 0

        changed = cimgui.igInputText(label_bytes, buf, buffer_size, flags, c_callback, user_data)
        if changed:
            return (True, buf.decode('utf-8'))
        else:
            return (False, value)
    finally:
        if callback_id != 0:
            _unregister_input_text_callback(callback_id)
        free(buf)


def input_text_multiline(label: str, value: str, buffer_size: int = 1024, size = (0, 0), flags: int = 0, callback = None):
    """Multiline text input with optional callback. Returns (changed, new_value)."""
    cdef bytes label_bytes = _to_bytes(label)
    cdef bytes value_bytes = _to_bytes(value)
    cdef char* buf = <char*>malloc(buffer_size)
    cdef size_t copy_len
    cdef size_t callback_id = 0
    cdef cimgui.ImGuiInputTextCallback c_callback = NULL
    cdef void* user_data = NULL

    if buf == NULL:
        raise MemoryError()

    # Setup callback if provided
    if callback is not None:
        callback_id = _register_input_text_callback(callback)
        c_callback = _input_text_callback_wrapper
        user_data = <void*>callback_id

    try:
        copy_len = min(len(value_bytes), buffer_size - 1)
        memcpy(buf, <char*>value_bytes, copy_len)
        buf[copy_len] = 0

        changed = cimgui.igInputTextMultiline(label_bytes, buf, buffer_size, _vec2(size), flags, c_callback, user_data)
        if changed:
            return (True, buf.decode('utf-8'))
        else:
            return (False, value)
    finally:
        if callback_id != 0:
            _unregister_input_text_callback(callback_id)
        free(buf)


def input_text_with_hint(label: str, hint: str, value: str, buffer_size: int = 256, flags: int = 0, callback = None):
    """Text input with placeholder hint and optional callback. Returns (changed, new_value)."""
    cdef bytes label_bytes = _to_bytes(label)
    cdef bytes hint_bytes = _to_bytes(hint)
    cdef bytes value_bytes = _to_bytes(value)
    cdef char* buf = <char*>malloc(buffer_size)
    cdef size_t copy_len
    cdef size_t callback_id = 0
    cdef cimgui.ImGuiInputTextCallback c_callback = NULL
    cdef void* user_data = NULL

    if buf == NULL:
        raise MemoryError()

    # Setup callback if provided
    if callback is not None:
        callback_id = _register_input_text_callback(callback)
        c_callback = _input_text_callback_wrapper
        user_data = <void*>callback_id

    try:
        copy_len = min(len(value_bytes), buffer_size - 1)
        memcpy(buf, <char*>value_bytes, copy_len)
        buf[copy_len] = 0

        changed = cimgui.igInputTextWithHint(label_bytes, hint_bytes, buf, buffer_size, flags, c_callback, user_data)
        if changed:
            return (True, buf.decode('utf-8'))
        else:
            return (False, value)
    finally:
        if callback_id != 0:
            _unregister_input_text_callback(callback_id)
        free(buf)


# ==============================================================================
# String Array Helper
# ==============================================================================

cdef inline const char** _string_array_to_c(list items, list items_bytes_holder):
    """Convert Python list of strings to C string array.

    items_bytes_holder must be kept alive while using the returned pointer.
    """
    cdef int count = len(items)
    cdef const char** arr = <const char**>malloc(count * sizeof(char*))
    if arr == NULL:
        raise MemoryError()

    for i, item in enumerate(items):
        b = _to_bytes(item)
        items_bytes_holder.append(b)  # Keep reference
        arr[i] = <const char*>b

    return arr


def list_box(label: str, current_item: int, items: list, height_in_items: int = -1):
    """List box. Returns (changed, selected_index)."""
    cdef int idx = current_item
    cdef list items_bytes = []
    cdef const char** items_ptr = _string_array_to_c(items, items_bytes)

    try:
        changed = cimgui.igListBox_Str_arr(_to_bytes(label), &idx, items_ptr, len(items), height_in_items)
        return (changed, idx)
    finally:
        free(<void*>items_ptr)


def combo(label: str, current_item: int, items: list, popup_max_height_in_items: int = -1):
    """Combo box (dropdown). Returns (changed, selected_index)."""
    cdef int idx = current_item
    cdef list items_bytes = []
    cdef const char** items_ptr = _string_array_to_c(items, items_bytes)

    try:
        changed = cimgui.igCombo_Str_arr(_to_bytes(label), &idx, items_ptr, len(items), popup_max_height_in_items)
        return (changed, idx)
    finally:
        free(<void*>items_ptr)


# ==============================================================================
# Auto-generated Global Functions
# ==============================================================================
{% for func in functions %}
{# 跳过包含未知类型或可变参数的函数 #}
{% set has_unknown = namespace(value=false) %}
{% for arg in func.args %}{% if arg.cython_type == '__UNKNOWN__' %}{% set has_unknown.value = true %}{% endif %}{% endfor %}
{% set override = overrides.get('functions', {}).get(func.ov_cimguiname, {}) %}
{% if not override.get('skip') and not func.skip and func.ret_cython != '__UNKNOWN__' and not has_unknown.value and not func.has_vararg %}
{# ------ Check if function has array arguments ------ #}
{% set array_args = [] %}
{% for arg in func.args %}
{% if arg.conversion and '_array_' in arg.conversion %}
{% set _ = array_args.append(arg) %}
{% endif %}
{% endfor %}
{# ------ Check if function has pointer arguments (output params) ------ #}
{% set ptr_args = [] %}
{% for arg in func.args %}
{% if arg.conversion and arg.conversion.endswith('_ptr') %}
{% set _ = ptr_args.append(arg) %}
{% endif %}
{% endfor %}

{% if ptr_args %}
{# ------ Functions with pointer output arguments ------ #}
{# Check if any ptr_arg is optional (has default) #}
{% set has_optional_ptr = namespace(value=false) %}
{% for ptr_arg in ptr_args %}{% if ptr_arg.default is not none %}{% set has_optional_ptr.value = true %}{% endif %}{% endfor %}

def {{ func.python_name }}({% for arg in func.args %}{{ arg.name }}{% if arg.default is not none %} = {{ arg.default }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %}):
    # Declare temp variables for output pointers
{% for ptr_arg in ptr_args %}
{% set ctype = {'bool_ptr': 'bint', 'int_ptr': 'int', 'uint_ptr': 'unsigned int', 'float_ptr': 'float', 'double_ptr': 'double', 'size_t_ptr': 'size_t'}[ptr_arg.conversion] %}
{% if ptr_arg.default is not none %}
    cdef {{ ctype }} _tmp_{{ ptr_arg.name }} = {{ ptr_arg.name }} if {{ ptr_arg.name }} is not None else 0
{% else %}
    cdef {{ ctype }} _tmp_{{ ptr_arg.name }} = {{ ptr_arg.name }}
{% endif %}
{% endfor %}
    # Call C function
{% if func.ret_python == 'None' %}
    cimgui.{{ func.ov_cimguiname }}({% for arg in func.args %}{{ convert_arg(arg) }}{% if not loop.last %}, {% endif %}{% endfor %})
    # Return updated values (None for optional params that were None)
{% if has_optional_ptr.value %}
    return ({% for ptr_arg in ptr_args %}{% if ptr_arg.default is not none %}({% endif %}{% if ptr_arg.conversion == 'bool_ptr' %}bool(_tmp_{{ ptr_arg.name }}){% else %}_tmp_{{ ptr_arg.name }}{% endif %}{% if ptr_arg.default is not none %} if {{ ptr_arg.name }} is not None else None){% endif %}{% if not loop.last %}, {% endif %}{% endfor %})
{% else %}
    return ({% for ptr_arg in ptr_args %}{% if ptr_arg.conversion == 'bool_ptr' %}bool(_tmp_{{ ptr_arg.name }}){% else %}_tmp_{{ ptr_arg.name }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %})
{% endif %}
{% else %}
    cdef {{ func.ret_cython }} _result = cimgui.{{ func.ov_cimguiname }}({% for arg in func.args %}{{ convert_arg(arg) }}{% if not loop.last %}, {% endif %}{% endfor %})
    # Return (result, updated_values)
{% if has_optional_ptr.value %}
    return (_result, {% for ptr_arg in ptr_args %}{% if ptr_arg.default is not none %}({% endif %}{% if ptr_arg.conversion == 'bool_ptr' %}bool(_tmp_{{ ptr_arg.name }}){% else %}_tmp_{{ ptr_arg.name }}{% endif %}{% if ptr_arg.default is not none %} if {{ ptr_arg.name }} is not None else None){% endif %}{% if not loop.last %}, {% endif %}{% endfor %})
{% else %}
    return (_result, {% for ptr_arg in ptr_args %}{% if ptr_arg.conversion == 'bool_ptr' %}bool(_tmp_{{ ptr_arg.name }}){% else %}_tmp_{{ ptr_arg.name }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %})
{% endif %}
{% endif %}

{% elif array_args %}
{# ------ Functions with array arguments need special handling ------ #}
def {{ func.python_name }}({% for arg in func.args %}{{ arg.name }}{% if arg.default is not none %} = {{ arg.default }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %}):
    # Declare C arrays for array arguments
{% for arr_arg in array_args %}
{% set arr_size = arr_arg.conversion.split('_')[-1] %}
{% if 'float' in arr_arg.conversion %}
    cdef float _arr_{{ arr_arg.name }}[{{ arr_size }}]
{% else %}
    cdef int _arr_{{ arr_arg.name }}[{{ arr_size }}]
{% endif %}
{% endfor %}
    # Copy input values to C arrays
{% for arr_arg in array_args %}
{% set arr_size = arr_arg.conversion.split('_')[-1]|int %}
{% for i in range(arr_size) %}
    _arr_{{ arr_arg.name }}[{{ i }}] = {{ arr_arg.name }}[{{ i }}]
{% endfor %}
{% endfor %}
    # Call C function
{% if func.ret_python == 'None' %}
    cimgui.{{ func.ov_cimguiname }}({% for arg in func.args %}{{ convert_arg(arg) }}{% if not loop.last %}, {% endif %}{% endfor %})
    # Return tuple with updated array values
    return ({% for arr_arg in array_args %}{% set arr_size = arr_arg.conversion.split('_')[-1]|int %}({% for i in range(arr_size) %}_arr_{{ arr_arg.name }}[{{ i }}]{% if not loop.last %}, {% endif %}{% endfor %}){% if not loop.last %}, {% endif %}{% endfor %})
{% else %}
    cdef {{ func.ret_cython }} _result = cimgui.{{ func.ov_cimguiname }}({% for arg in func.args %}{{ convert_arg(arg) }}{% if not loop.last %}, {% endif %}{% endfor %})
    # Return (result, updated_array_values)
    return (_result, {% for arr_arg in array_args %}{% set arr_size = arr_arg.conversion.split('_')[-1]|int %}({% for i in range(arr_size) %}_arr_{{ arr_arg.name }}[{{ i }}]{% if not loop.last %}, {% endif %}{% endfor %}){% if not loop.last %}, {% endif %}{% endfor %})
{% endif %}

{% else %}
{# ------ Normal functions without array arguments ------ #}
def {{ func.python_name }}({% for arg in func.args %}{{ arg.name }}{% if arg.default is not none %} = {{ arg.default }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %}):
{% if func.ret_python == 'None' %}
    cimgui.{{ func.ov_cimguiname }}({% for arg in func.args %}{{ convert_arg(arg) }}{% if not loop.last %}, {% endif %}{% endfor %})
{% elif func.ret_conversion == 'vec2_to_tuple' %}
    cdef cimgui.ImVec2 result = cimgui.{{ func.ov_cimguiname }}({% for arg in func.args %}{{ convert_arg(arg) }}{% if not loop.last %}, {% endif %}{% endfor %})
    return _vec2_to_tuple(result)
{% elif func.ret_conversion == 'vec4_to_tuple' %}
    cdef cimgui.ImVec4 result = cimgui.{{ func.ov_cimguiname }}({% for arg in func.args %}{{ convert_arg(arg) }}{% if not loop.last %}, {% endif %}{% endfor %})
    return _vec4_to_tuple(result)
{% elif func.ret_conversion == 'char_ptr_to_str' %}
    cdef const char* _cstr = cimgui.{{ func.ov_cimguiname }}({% for arg in func.args %}{{ convert_arg(arg) }}{% if not loop.last %}, {% endif %}{% endfor %})
    return _cstr.decode('utf-8') if _cstr != NULL else ''
{% elif func.ret_wrapper %}
    cdef void* _ptr = cimgui.{{ func.ov_cimguiname }}({% for arg in func.args %}{{ convert_arg(arg) }}{% if not loop.last %}, {% endif %}{% endfor %})
    return {{ func.ret_wrapper }}._wrap(<size_t>_ptr) if _ptr != NULL else None
{% elif func.ret_cython.endswith('*') %}
    return <size_t>cimgui.{{ func.ov_cimguiname }}({% for arg in func.args %}{{ convert_arg(arg) }}{% if not loop.last %}, {% endif %}{% endfor %})
{% else %}
    return cimgui.{{ func.ov_cimguiname }}({% for arg in func.args %}{{ convert_arg(arg) }}{% if not loop.last %}, {% endif %}{% endfor %})
{% endif %}
{% endif %}
{% endif %}
{% endfor %}

# ==============================================================================
# Overload Dispatch Functions (自动生成)
# ==============================================================================
{% for dispatcher in dispatchers %}
{% set merged_args = dispatcher.merged_args %}

def {{ dispatcher.python_name }}({% for arg in merged_args %}{{ arg.name }}{% if arg.default is not none %} = {{ arg.default }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %}):
    """Overload dispatch for {{ dispatcher.python_name }}."""
{% if dispatcher.dispatch == 'by_type' %}
{% set type_arg_idx = dispatcher.type_arg %}
{% set type_arg_name = merged_args[type_arg_idx].name %}
{% for variant in dispatcher.variants %}
{% if loop.first %}
    if isinstance({{ type_arg_name }}, {{ variant.key }}):
{% else %}
    elif isinstance({{ type_arg_name }}, {{ variant.key }}):
{% endif %}
        return {{ variant.internal_name }}({{ variant.call_args }})
{% endfor %}
    else:
        raise TypeError(f"{{ dispatcher.python_name }}: unsupported type for argument '{{ type_arg_name }}': {type({{ type_arg_name }})}")
{% elif dispatcher.dispatch == 'by_optional_arg' %}
{% set check_arg_name = dispatcher.check_arg %}
    if {{ check_arg_name }} is not None:
{% for variant in dispatcher.variants %}{% if variant.key == 'with' %}
        return {{ variant.internal_name }}({{ variant.call_args }})
{% endif %}{% endfor %}
    else:
{% for variant in dispatcher.variants %}{% if variant.key == 'without' %}
        return {{ variant.internal_name }}({{ variant.call_args }})
{% endif %}{% endfor %}
{% endif %}

{% endfor %}

# ==============================================================================
# Enum Types (自动生成)
# ==============================================================================
from enum import IntEnum, IntFlag

{% for enum in enums %}
class {{ enum.python_class_name }}({{ enum.python_base_class }}):
    """{{ enum.name }}"""
{% for name, value in enum.values %}
{% set member_name = name.replace(enum.name, '').lstrip('_') %}
{% if member_name and member_name[0].isalpha() and member_name not in ('None', 'True', 'False') %}
    {{ member_name }} = {{ value }}
{% elif member_name == 'None' %}
    NONE = {{ value }}
{% endif %}
{% endfor %}

{% endfor %}

# ==============================================================================
# Enum Constants (模块级别名 - 向后兼容)
# ==============================================================================
{% for enum in enums %}
# {{ enum.name }}
{% for name, value in enum.values %}
{{ name }} = {{ value }}
{% endfor %}

{% endfor %}
# ==============================================================================
# Compatibility Aliases (原始 ImGui 命名 - 便于 AI agent 生成代码)
# ==============================================================================

# Enum class aliases (ImGuiWindowFlags_ -> ImGuiWindowFlags -> WindowFlags)
{% for enum in enums %}
{% set alias_name = enum.name.rstrip('_') %}
{{ alias_name }} = {{ enum.python_class_name }}
{% endfor %}

# Wrapper class aliases (ImFont -> Font, ImGuiContext -> Context)
{% for ctype, (pyname, has_methods, full_fields) in type_map.WRAPPER_TYPES.items() %}
{{ ctype }} = {{ pyname }}
{% endfor %}

# Function aliases (igXXX -> xxx)
# Note: Most common functions are already accessible via simplified names
