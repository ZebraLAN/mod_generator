# cython: language_level=3
# cython: embedsignature=True
"""imgui_core.pyx - Auto-generated ImGui bindings (纯 C API)

DO NOT EDIT - regenerate with: python codegen/compiler.py

架构说明：
- 直接调用 cimgui 的纯 C 函数
- 不涉及 C++ 类型或转换
- ImVec2/ImVec4 等是 cimgui 定义的纯 C 结构体
"""

from libc.stdlib cimport malloc, free
from libc.string cimport memcpy, strlen
cimport cimgui

# ==============================================================================
# Helpers
# ==============================================================================

cdef inline bytes _to_bytes(s):
    """str -> bytes"""
    if isinstance(s, bytes):
        return s
    if s is None:
        return b''
    return s.encode('utf-8')


# ==============================================================================
# Value-Type Struct Conversion Functions (自动生成)
# ==============================================================================
{% for struct in structs.values() if struct.is_value_type and struct.has_simple_fields %}
{% set conv_name = (struct.name | strip_im_prefix) | snake_case %}

cdef inline cimgui.{{ struct.name }} _{{ conv_name }}(val):
    """tuple/list -> {{ struct.name }}"""
    cdef cimgui.{{ struct.name }} v
    if val is None:
{% for field in struct.simple_fields %}
{% if field.cython_type.endswith('*') %}
        v.{{ field.name }} = NULL
{% elif field.cython_type.startswith('Im') %}
        v.{{ field.name }} = _{{ (field.cython_type | strip_im_prefix) | snake_case }}(None)
{% else %}
        v.{{ field.name }} = 0
{% endif %}
{% endfor %}
    else:
{% for field in struct.simple_fields %}
{% if field.cython_type == 'float' %}
        v.{{ field.name }} = <float>val[{{ loop.index0 }}]
{% elif field.cython_type in ('int', 'bint') %}
        v.{{ field.name }} = <int>val[{{ loop.index0 }}]
{% elif field.cython_type == 'void*' %}
        v.{{ field.name }} = <void*><size_t>val[{{ loop.index0 }}]
{% elif field.cython_type.endswith('*') %}
        v.{{ field.name }} = <cimgui.{{ field.cython_type[:-1] }}*><size_t>val[{{ loop.index0 }}]
{% elif field.cython_type.startswith('Im') %}
        v.{{ field.name }} = _{{ (field.cython_type | strip_im_prefix) | snake_case }}(val[{{ loop.index0 }}])
{% else %}
        v.{{ field.name }} = val[{{ loop.index0 }}]
{% endif %}
{% endfor %}
    return v


cdef inline tuple _{{ conv_name }}_to_tuple(cimgui.{{ struct.name }} v):
    """{{ struct.name }} -> tuple"""
    return ({% for field in struct.simple_fields %}{% if field.cython_type.endswith('*') %}<size_t>v.{{ field.name }}{% else %}v.{{ field.name }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %})

{% endfor %}

{# ============================================================================
   Macro: convert argument for C call
   自动匹配值类型结构体的转换函数
   ============================================================================ #}
{% macro convert_arg(arg) -%}
{% if arg.conversion == 'to_bytes' -%}
_to_bytes({{ arg.name }})
{%- elif arg.conversion == 'ptr' -%}
{# For ptr conversion: void* and const T* can use simple cast #}
{% if arg.cython_type == 'void*' or arg.cython_type == 'const void*' -%}
<void*><size_t>{{ arg.name }}
{%- elif arg.cython_type.startswith('const ') -%}
{# const float*, const int* etc - cast to non-const pointer then to target #}
<{{ arg.cython_type[6:] }}><size_t>{{ arg.name }}
{%- else -%}
<cimgui.{{ arg.cython_type }}><size_t>{{ arg.name }}
{%- endif %}
{%- elif arg.conversion and arg.conversion.startswith('float_array') -%}
_arr_{{ arg.name }}
{%- elif arg.conversion and arg.conversion.startswith('int_array') -%}
_arr_{{ arg.name }}
{%- elif arg.conversion and arg.conversion.endswith('_ptr') -%}
{# Native pointer types: pass address of temp variable #}
&_tmp_{{ arg.name }}
{%- elif arg.conversion -%}
{# Value-type struct conversion: call _<conv_name>(arg) #}
_{{ arg.conversion }}({{ arg.name }})
{%- else -%}
{{ arg.name }}
{%- endif %}
{%- endmacro %}

{# ============================================================================
   Macro: check if function has pointer arguments (output params)
   ============================================================================ #}
{% macro has_ptr_args(func) -%}
{% for arg in func.args %}{% if arg.conversion and arg.conversion.endswith('_ptr') %}1{% endif %}{% endfor %}
{%- endmacro %}

{# ============================================================================
   Macro: check if function has array arguments
   ============================================================================ #}
{% macro has_array_args(func) -%}
{% for arg in func.args %}{% if arg.conversion and ('_array_' in arg.conversion) %}1{% endif %}{% endfor %}
{%- endmacro %}

# ==============================================================================
# Core Functions (需要特殊处理)
# ==============================================================================

def destroy_context(ctx = None):
    """Destroy ImGui context. ctx=None to destroy current context."""
    cdef cimgui.ImGuiContext* ptr = NULL
    if ctx is not None:
        ptr = <cimgui.ImGuiContext*><size_t>ctx
    cimgui.igDestroyContext(ptr)


def begin(name: str, closable = None, flags: int = 0):
    """Begin a window.

    Args:
        name: Window title
        closable: If None, window has no close button. If True/False, initial open state.

    Returns:
        If closable is None: bool (visible)
        If closable is not None: (visible, open) tuple
    """
    cdef bytes name_bytes = _to_bytes(name)
    cdef bint result
    cdef bint p_open = True

    if closable is None:
        result = cimgui.igBegin(name_bytes, NULL, flags)
        return result
    else:
        p_open = closable
        result = cimgui.igBegin(name_bytes, &p_open, flags)
        return (result, bool(p_open))


def text(txt: str):
    """Display text (uses TextUnformatted internally)."""
    cdef bytes txt_bytes = _to_bytes(txt)
    cimgui.igTextUnformatted(txt_bytes, NULL)


def input_text(label: str, value: str, buffer_size: int = 256, flags: int = 0):
    """Text input widget. Returns (changed, new_value)."""
    cdef bytes label_bytes = _to_bytes(label)
    cdef bytes value_bytes = _to_bytes(value)
    cdef char* buf = <char*>malloc(buffer_size)
    cdef size_t copy_len

    if buf == NULL:
        raise MemoryError()

    try:
        copy_len = min(len(value_bytes), buffer_size - 1)
        memcpy(buf, <char*>value_bytes, copy_len)
        buf[copy_len] = 0

        changed = cimgui.igInputText(label_bytes, buf, buffer_size, flags, NULL, NULL)
        if changed:
            return (True, buf.decode('utf-8'))
        else:
            return (False, value)
    finally:
        free(buf)


def input_text_multiline(label: str, value: str, buffer_size: int = 1024, size = (0, 0), flags: int = 0):
    """Multiline text input. Returns (changed, new_value)."""
    cdef bytes label_bytes = _to_bytes(label)
    cdef bytes value_bytes = _to_bytes(value)
    cdef char* buf = <char*>malloc(buffer_size)
    cdef size_t copy_len

    if buf == NULL:
        raise MemoryError()

    try:
        copy_len = min(len(value_bytes), buffer_size - 1)
        memcpy(buf, <char*>value_bytes, copy_len)
        buf[copy_len] = 0

        changed = cimgui.igInputTextMultiline(label_bytes, buf, buffer_size, _vec2(size), flags, NULL, NULL)
        if changed:
            return (True, buf.decode('utf-8'))
        else:
            return (False, value)
    finally:
        free(buf)


def input_text_with_hint(label: str, hint: str, value: str, buffer_size: int = 256, flags: int = 0):
    """Text input with placeholder hint. Returns (changed, new_value)."""
    cdef bytes label_bytes = _to_bytes(label)
    cdef bytes hint_bytes = _to_bytes(hint)
    cdef bytes value_bytes = _to_bytes(value)
    cdef char* buf = <char*>malloc(buffer_size)
    cdef size_t copy_len

    if buf == NULL:
        raise MemoryError()

    try:
        copy_len = min(len(value_bytes), buffer_size - 1)
        memcpy(buf, <char*>value_bytes, copy_len)
        buf[copy_len] = 0

        changed = cimgui.igInputTextWithHint(label_bytes, hint_bytes, buf, buffer_size, flags, NULL, NULL)
        if changed:
            return (True, buf.decode('utf-8'))
        else:
            return (False, value)
    finally:
        free(buf)


# ==============================================================================
# String Array Helper
# ==============================================================================

cdef inline const char** _string_array_to_c(list items, list items_bytes_holder):
    """Convert Python list of strings to C string array.

    items_bytes_holder must be kept alive while using the returned pointer.
    """
    cdef int count = len(items)
    cdef const char** arr = <const char**>malloc(count * sizeof(char*))
    if arr == NULL:
        raise MemoryError()

    for i, item in enumerate(items):
        b = _to_bytes(item)
        items_bytes_holder.append(b)  # Keep reference
        arr[i] = <const char*>b

    return arr


def list_box(label: str, current_item: int, items: list, height_in_items: int = -1):
    """List box. Returns (changed, selected_index)."""
    cdef int idx = current_item
    cdef list items_bytes = []
    cdef const char** items_ptr = _string_array_to_c(items, items_bytes)

    try:
        changed = cimgui.igListBox_Str_arr(_to_bytes(label), &idx, items_ptr, len(items), height_in_items)
        return (changed, idx)
    finally:
        free(<void*>items_ptr)


def combo(label: str, current_item: int, items: list, popup_max_height_in_items: int = -1):
    """Combo box (dropdown). Returns (changed, selected_index)."""
    cdef int idx = current_item
    cdef list items_bytes = []
    cdef const char** items_ptr = _string_array_to_c(items, items_bytes)

    try:
        changed = cimgui.igCombo_Str_arr(_to_bytes(label), &idx, items_ptr, len(items), popup_max_height_in_items)
        return (changed, idx)
    finally:
        free(<void*>items_ptr)


# ==============================================================================
# Auto-generated Global Functions
# ==============================================================================
{% for func in functions %}
{# 跳过包含未知类型或可变参数的函数 #}
{% set has_unknown = namespace(value=false) %}
{% for arg in func.args %}{% if arg.cython_type == '__UNKNOWN__' %}{% set has_unknown.value = true %}{% endif %}{% endfor %}
{% set override = overrides.get('functions', {}).get(func.ov_cimguiname, {}) %}
{% if not override.get('skip') and not func.skip and func.ret_cython != '__UNKNOWN__' and not has_unknown.value and not func.has_vararg %}
{# ------ Check if function has array arguments ------ #}
{% set array_args = [] %}
{% for arg in func.args %}
{% if arg.conversion and '_array_' in arg.conversion %}
{% set _ = array_args.append(arg) %}
{% endif %}
{% endfor %}
{# ------ Check if function has pointer arguments (output params) ------ #}
{% set ptr_args = [] %}
{% for arg in func.args %}
{% if arg.conversion and arg.conversion.endswith('_ptr') %}
{% set _ = ptr_args.append(arg) %}
{% endif %}
{% endfor %}

{% if ptr_args %}
{# ------ Functions with pointer output arguments ------ #}
def {{ func.python_name }}({% for arg in func.args %}{{ arg.name }}{% if arg.default is not none %} = {{ arg.default }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %}):
    # Declare temp variables for output pointers
{% for ptr_arg in ptr_args %}
{% if ptr_arg.conversion == 'bool_ptr' %}
    cdef bint _tmp_{{ ptr_arg.name }} = {{ ptr_arg.name }}
{% elif ptr_arg.conversion == 'int_ptr' %}
    cdef int _tmp_{{ ptr_arg.name }} = {{ ptr_arg.name }}
{% elif ptr_arg.conversion == 'uint_ptr' %}
    cdef unsigned int _tmp_{{ ptr_arg.name }} = {{ ptr_arg.name }}
{% elif ptr_arg.conversion == 'float_ptr' %}
    cdef float _tmp_{{ ptr_arg.name }} = {{ ptr_arg.name }}
{% elif ptr_arg.conversion == 'double_ptr' %}
    cdef double _tmp_{{ ptr_arg.name }} = {{ ptr_arg.name }}
{% elif ptr_arg.conversion == 'size_t_ptr' %}
    cdef size_t _tmp_{{ ptr_arg.name }} = {{ ptr_arg.name }}
{% endif %}
{% endfor %}
    # Call C function
{% if func.ret_python == 'None' %}
    cimgui.{{ func.ov_cimguiname }}({% for arg in func.args %}{{ convert_arg(arg) }}{% if not loop.last %}, {% endif %}{% endfor %})
    # Return updated values
    return ({% for ptr_arg in ptr_args %}{% if ptr_arg.conversion == 'bool_ptr' %}bool(_tmp_{{ ptr_arg.name }}){% else %}_tmp_{{ ptr_arg.name }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %})
{% else %}
    cdef {{ func.ret_cython }} _result = cimgui.{{ func.ov_cimguiname }}({% for arg in func.args %}{{ convert_arg(arg) }}{% if not loop.last %}, {% endif %}{% endfor %})
    # Return (result, updated_values)
    return (_result, {% for ptr_arg in ptr_args %}{% if ptr_arg.conversion == 'bool_ptr' %}bool(_tmp_{{ ptr_arg.name }}){% else %}_tmp_{{ ptr_arg.name }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %})
{% endif %}

{% elif array_args %}
{# ------ Functions with array arguments need special handling ------ #}
def {{ func.python_name }}({% for arg in func.args %}{{ arg.name }}{% if arg.default is not none %} = {{ arg.default }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %}):
    # Declare C arrays for array arguments
{% for arr_arg in array_args %}
{% set arr_size = arr_arg.conversion.split('_')[-1] %}
{% if 'float' in arr_arg.conversion %}
    cdef float _arr_{{ arr_arg.name }}[{{ arr_size }}]
{% else %}
    cdef int _arr_{{ arr_arg.name }}[{{ arr_size }}]
{% endif %}
{% endfor %}
    # Copy input values to C arrays
{% for arr_arg in array_args %}
{% set arr_size = arr_arg.conversion.split('_')[-1]|int %}
{% for i in range(arr_size) %}
    _arr_{{ arr_arg.name }}[{{ i }}] = {{ arr_arg.name }}[{{ i }}]
{% endfor %}
{% endfor %}
    # Call C function
{% if func.ret_python == 'None' %}
    cimgui.{{ func.ov_cimguiname }}({% for arg in func.args %}{{ convert_arg(arg) }}{% if not loop.last %}, {% endif %}{% endfor %})
    # Return tuple with updated array values
    return ({% for arr_arg in array_args %}{% set arr_size = arr_arg.conversion.split('_')[-1]|int %}({% for i in range(arr_size) %}_arr_{{ arr_arg.name }}[{{ i }}]{% if not loop.last %}, {% endif %}{% endfor %}){% if not loop.last %}, {% endif %}{% endfor %})
{% else %}
    cdef {{ func.ret_cython }} _result = cimgui.{{ func.ov_cimguiname }}({% for arg in func.args %}{{ convert_arg(arg) }}{% if not loop.last %}, {% endif %}{% endfor %})
    # Return (result, updated_array_values)
    return (_result, {% for arr_arg in array_args %}{% set arr_size = arr_arg.conversion.split('_')[-1]|int %}({% for i in range(arr_size) %}_arr_{{ arr_arg.name }}[{{ i }}]{% if not loop.last %}, {% endif %}{% endfor %}){% if not loop.last %}, {% endif %}{% endfor %})
{% endif %}

{% else %}
{# ------ Normal functions without array arguments ------ #}
def {{ func.python_name }}({% for arg in func.args %}{{ arg.name }}{% if arg.default is not none %} = {{ arg.default }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %}):
{% if func.ret_python == 'None' %}
    cimgui.{{ func.ov_cimguiname }}({% for arg in func.args %}{{ convert_arg(arg) }}{% if not loop.last %}, {% endif %}{% endfor %})
{% elif func.ret_conversion == 'vec2_to_tuple' %}
    cdef cimgui.ImVec2 result = cimgui.{{ func.ov_cimguiname }}({% for arg in func.args %}{{ convert_arg(arg) }}{% if not loop.last %}, {% endif %}{% endfor %})
    return _vec2_to_tuple(result)
{% elif func.ret_conversion == 'vec4_to_tuple' %}
    cdef cimgui.ImVec4 result = cimgui.{{ func.ov_cimguiname }}({% for arg in func.args %}{{ convert_arg(arg) }}{% if not loop.last %}, {% endif %}{% endfor %})
    return _vec4_to_tuple(result)
{% elif func.ret_cython.endswith('*') %}
    return <size_t>cimgui.{{ func.ov_cimguiname }}({% for arg in func.args %}{{ convert_arg(arg) }}{% if not loop.last %}, {% endif %}{% endfor %})
{% else %}
    return cimgui.{{ func.ov_cimguiname }}({% for arg in func.args %}{{ convert_arg(arg) }}{% if not loop.last %}, {% endif %}{% endfor %})
{% endif %}
{% endif %}
{% endif %}
{% endfor %}

# ==============================================================================
# Overload Dispatch Functions (自动生成)
# ==============================================================================
{% for dispatcher in dispatchers %}
{% set merged_args = dispatcher.merged_args %}

def {{ dispatcher.python_name }}({% for arg in merged_args %}{{ arg.name }}{% if arg.default is not none %} = {{ arg.default }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %}):
    """Overload dispatch for {{ dispatcher.python_name }}."""
{% if dispatcher.dispatch == 'by_type' %}
{% set type_arg_idx = dispatcher.type_arg %}
{% set type_arg_name = merged_args[type_arg_idx].name %}
{% for variant in dispatcher.variants %}
{% if loop.first %}
    if isinstance({{ type_arg_name }}, {{ variant.key }}):
{% else %}
    elif isinstance({{ type_arg_name }}, {{ variant.key }}):
{% endif %}
        return {{ variant.internal_name }}({{ variant.call_args }})
{% endfor %}
    else:
        raise TypeError(f"{{ dispatcher.python_name }}: unsupported type for argument '{{ type_arg_name }}': {type({{ type_arg_name }})}")
{% elif dispatcher.dispatch == 'by_optional_arg' %}
{% set check_arg_name = dispatcher.check_arg %}
    if {{ check_arg_name }} is not None:
{% for variant in dispatcher.variants %}{% if variant.key == 'with' %}
        return {{ variant.internal_name }}({{ variant.call_args }})
{% endif %}{% endfor %}
    else:
{% for variant in dispatcher.variants %}{% if variant.key == 'without' %}
        return {{ variant.internal_name }}({{ variant.call_args }})
{% endif %}{% endfor %}
{% endif %}

{% endfor %}
